+++
title = "Skills and Expertise"
slug = "expertise"
+++
In the past ten years of programming, I have dealt with an enormous amount of programming languages and frameworks, from C to Ruby on Rails and from Java 6 to Python Django. As a result, I have figured out which languages and frameworks suit me best, and how I can achieve the best results to best meet the needs of the end user.

In recent years I have specialised in a few stacks, as can be read below. Although of course I have my preferences, I will always choose _the best tool for the job_, regardless of my perfonal preference.

I have worked both as a hands-on software engineer and as a technical lead, with responsibilities that go beyond just software development (software architecture, training developers with new technologies, determining the feature road map).

## Working method

*Methods I employ to deliver elegant, efficient, readable, understandable and maintainable code that adds value to a company and/or product.*

* "Always choose the best tool for the job"
* Cloud and application structure using [The Twelve-Factor App](https://12factor.net/)
* Software architecture through the principles of [The Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html), [DDD](https://en.wikipedia.org/wiki/Domain-driven_design) and [Layered Architecture](https://en.wikipedia.org/wiki/Multitier_architecture).
* Prevention of [technical debt](https://en.wikipedia.org/wiki/Technical_debt), short term and long term
* Everything (even [infrastructure as code](https://en.wikipedia.org/wiki/Infrastructure_as_code)) in version control (Git) via [GitFlow](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow).
* Project management via SCRUM/Agile principle, without unnecessary meetings
* Bringing together Development, Security and Operations through [DevSecOps](https://www.devsecops.org/) and [secure by design](https://en.wikipedia.org/wiki/Secure_by_design).
* Prioritise via the [MoSCoW method](https://en.wikipedia.org/wiki/MoSCoW_method) and the [80 / 20 rule](https://en.wikipedia.org/wiki/Pareto_principle).
* Development on the basis of Test-Driven Development (TDD)
* Functional programming where possible
* [SOLID](https://en.wikipedia.org/wiki/SOLID), [KISS](https://en.wikipedia.org/wiki/KISS_principle) and [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) code
* Versioning according to [Semantic Versioning](https://semver.org/)
* Use of [Design Patterns](https://en.wikipedia.org/wiki/Software_design_pattern) to improve readability, performance and maintainability
* Adhere to the [ACM Code of Ethics](https://www.acm.org/code-of-ethics)
* Use of free (open-source) software where possible


## Technology used

The techniques I'm currently working with the most and am most familar with are in **bold**.

### Backend/server development

* **Golang** (Gin, Echo)
* Typescript (NodeJS, Express, Deno)
* Kotlin/Java (Spring Boot)
* Rust
* Haskell

_With mostly **PostgreSQL** as the underlying database._

### Front-end and mobile development

* **React with Typescript** (with Redux, Styled-Components, NextJS)
* **React Native** (Expo or bare)
* Progressive Web Apps
* Elm

### Site Reliability Engineering and DevOps

* **Linux** (Arch, Ubuntu, CentOS)
* **Docker and Kubernetes**
* **Infrastructure and provisioning** (Ansible, Terraform, Shell)
* **CI/CD** (GitLab)
* Systems integration
* Cloud (DigitalOcean, AWS)
* Nginx

### Domain specific

* **Compilers, parsers, DSLs**: Golang, Rust, Haskell
* Systems programming: Rust, Golang, C
* Data science: SQL, Python, Javascript

---

## Learning

Currently, I spend around 20 hours per week on self-education. Some of it focused on computer science, most of it on other subjects (like philosophy, history and linguistics). You can read more on my [learning page](/learning).

The old learning page is archived [here](/archive/learning).
